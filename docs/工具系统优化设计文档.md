# AgentUniverse 工具系统优化设计文档

## 1. 当前系统分析

### 1.1 现有架构

#### 工具存储
- **工具元数据**：存储在 `tools_db` 表中
  - 包含：id, name, description, task, agent_type, input_params, output_type, tool_type, agent_class_name
  - 支持两种类型：`function` 和 `agent_as_tool`

- **Agent 工具关联**：存储在 `agent_db` 表的 `tool_ids` 字段（JSON 数组）
  - 存储的是工具名称/ID 列表
  - Agent 加载时通过 `tool_ids` 重新创建工具实例

#### 工具创建
- **硬编码方式**：`tool_loader.py` 中的 `create_tool_by_name` 函数
  - 使用 if-elif 链匹配工具名称
  - 需要手动导入和创建每个工具
  - 添加新工具需要修改代码

#### 工具类型
1. **Function Tools**：使用 `@function_tool` 装饰器的函数
   - 需要 agent 实例作为上下文
   - 例如：`send_message`, `create_notebook`, `modify_notes`

2. **Agent as Tool**：Agent 实例通过 `as_tool()` 方法转换
   - 存储在 tools_db 中，包含 agent_class_name
   - 需要运行时动态创建 Agent 实例

### 1.2 存在的问题

1. **硬编码问题**
   - 工具创建逻辑硬编码在 `create_tool_by_name` 中
   - 添加新工具需要修改多个文件
   - 难以维护和扩展

2. **缺乏统一注册机制**
   - `register_tool_creator` 函数存在但未使用
   - 没有自动发现机制
   - 工具分散在各个文件中

3. **Agent as Tool 加载不完善**
   - 当前只支持 function tool 的加载
   - agent_as_tool 需要特殊处理逻辑

4. **工具管理困难**
   - 无法动态添加/删除工具
   - 工具变更需要重启系统
   - 缺乏工具版本管理

## 2. 设计目标

### 2.1 核心目标

1. **装饰器驱动的工具注册**
   - 使用装饰器轻松注册工具
   - 自动发现和注册工具
   - 减少样板代码

2. **数据库驱动的工具管理**
   - 工具元数据存储在数据库
   - 支持动态添加/删除/更新工具
   - 工具与 agent 的关联存储在数据库

3. **统一的工具加载机制**
   - 支持 function tool 和 agent_as_tool
   - 自动从数据库加载工具
   - 支持工具依赖和条件加载

4. **向后兼容**
   - 保持现有 API 不变
   - 渐进式迁移
   - 支持旧代码继续工作

## 3. 设计方案

### 3.1 工具注册装饰器

#### 3.1.1 Function Tool 装饰器

```python
from backend.tools.tool_registry import register_function_tool

@register_function_tool(
    tool_id="send_message",
    name="send_message",
    description="向指定ID的agent发送消息",
    agent_types=["BaseAgent"],  # 哪些 agent 类型可以使用
    required_agent_attrs=["load_agent_from_db_by_id"],  # agent 需要的属性
)
def create_send_message_tool(agent: 'BaseAgent'):
    """工具创建函数"""
    @function_tool
    def send_message(id: str, message: str) -> str:
        # ... 实现
        pass
    return send_message
```

#### 3.1.2 Agent as Tool 装饰器

```python
from backend.tools.tool_registry import register_agent_as_tool

@register_agent_as_tool(
    tool_id="outline_maker_agent",
    name="outline_maker_agent",
    description="从文件生成学习大纲的Agent",
    agent_class_name="OutlineMakerAgent",
    agent_types=["SpecializedAgent"],  # 哪些 agent 类型可以使用
)
class OutlineMakerAgent(Agent):
    # ... Agent 实现
    pass
```

### 3.2 工具注册表（Tool Registry）

#### 3.2.1 核心组件

```python
# backend/tools/tool_registry.py

class ToolRegistry:
    """工具注册表 - 管理所有工具"""
    
    def __init__(self):
        self._function_tools: Dict[str, ToolMetadata] = {}
        self._agent_as_tools: Dict[str, AgentAsToolMetadata] = {}
        self._tool_creators: Dict[str, Callable] = {}
    
    def register_function_tool(self, tool_id: str, creator_func: Callable, metadata: ToolMetadata):
        """注册 function tool"""
        pass
    
    def register_agent_as_tool(self, tool_id: str, agent_class: Type, metadata: AgentAsToolMetadata):
        """注册 agent as tool"""
        pass
    
    def create_tool(self, tool_id: str, agent: 'BaseAgent', **kwargs) -> Optional[Any]:
        """创建工具实例"""
        pass
    
    def get_tool_metadata(self, tool_id: str) -> Optional[ToolMetadata]:
        """获取工具元数据"""
        pass
    
    def sync_to_database(self, db_path: Optional[str] = None):
        """同步工具元数据到数据库"""
        pass
```

#### 3.2.2 工具元数据

```python
@dataclass
class ToolMetadata:
    """工具元数据"""
    tool_id: str
    name: str
    description: str
    task: str
    agent_types: List[str]  # 哪些 agent 类型可以使用
    input_params: Dict[str, ParamInfo]
    output_type: str
    output_description: Optional[str] = None
    tool_type: str = "function"  # "function" or "agent_as_tool"
    creator_func: Optional[Callable] = None
    required_agent_attrs: List[str] = []  # agent 需要的属性
    condition_func: Optional[Callable] = None  # 条件加载函数

@dataclass
class AgentAsToolMetadata(ToolMetadata):
    """Agent as Tool 元数据"""
    agent_class_name: str
    agent_class: Optional[Type] = None
    agent_init_params: Optional[Dict] = None  # Agent 初始化参数模板
```

### 3.3 工具加载机制

#### 3.3.1 Agent 工具加载

```python
# backend/agent/BaseAgent.py

class BaseAgent(Agent):
    def _recreate_tools(self):
        """从数据库重新创建工具"""
        from backend.tools.tool_registry import get_tool_registry
        
        registry = get_tool_registry()
        
        # 从数据库获取 tool_ids
        tool_ids = self._get_tool_ids_from_db()
        
        # 创建工具实例
        tools = []
        for tool_id in tool_ids:
            tool = registry.create_tool(tool_id, self)
            if tool:
                tools.append(tool)
        
        self.tools = tools
    
    def add_tool(self, tool_id: str):
        """动态添加工具"""
        registry = get_tool_registry()
        tool = registry.create_tool(tool_id, self)
        if tool:
            self.tools.append(tool)
            self._save_tool_ids_to_db()
    
    def remove_tool(self, tool_id: str):
        """动态删除工具"""
        self.tools = [t for t in self.tools if getattr(t, '_tool_id', None) != tool_id]
        self._save_tool_ids_to_db()
```

#### 3.3.2 Agent as Tool 创建

```python
def create_agent_as_tool(tool_id: str, agent: 'BaseAgent', **kwargs):
    """创建 agent as tool 实例"""
    metadata = registry.get_tool_metadata(tool_id)
    if not metadata or metadata.tool_type != "agent_as_tool":
        return None
    
    # 动态导入 agent 类
    agent_class = metadata.agent_class
    if not agent_class:
        agent_class = _import_agent_class(metadata.agent_class_name)
    
    # 创建 agent 实例（需要根据实际情况调整参数）
    agent_instance = agent_class(**kwargs)
    
    # 转换为 tool
    return agent_instance.as_tool(
        tool_name=metadata.name,
        tool_description=metadata.description
    )
```

### 3.4 自动发现和注册

#### 3.4.1 工具发现机制

```python
# backend/tools/tool_discovery.py

def discover_and_register_tools():
    """自动发现并注册所有工具"""
    import importlib
    import pkgutil
    
    # 扫描 tools 目录下的所有模块
    tools_package = 'backend.tools'
    
    for importer, modname, ispkg in pkgutil.iter_modules([tools_package]):
        if not ispkg:
            try:
                module = importlib.import_module(f"{tools_package}.{modname}")
                # 模块加载时会自动执行装饰器注册
            except Exception as e:
                logger.warning(f"Failed to load tool module {modname}: {e}")
    
    # 同步到数据库
    registry = get_tool_registry()
    registry.sync_to_database()
```

#### 3.4.2 启动时初始化

```python
# backend/main.py 或 backend/__init__.py

def init_tool_system():
    """初始化工具系统"""
    from backend.tools.tool_discovery import discover_and_register_tools
    
    # 自动发现和注册工具
    discover_and_register_tools()
    
    # 确保数据库中有所有工具的元数据
    registry = get_tool_registry()
    registry.sync_to_database()
```

### 3.5 数据库同步

#### 3.5.1 工具元数据同步

```python
def sync_to_database(self, db_path: Optional[str] = None):
    """同步工具元数据到数据库"""
    from backend.database.tools_db import save_tool
    
    # 同步 function tools
    for tool_id, metadata in self._function_tools.items():
        save_tool(
            tool_id=tool_id,
            name=metadata.name,
            description=metadata.description,
            task=metadata.task,
            agent_type=",".join(metadata.agent_types),  # 多个类型用逗号分隔
            input_params=metadata.input_params,
            output_type=metadata.output_type,
            output_description=metadata.output_description,
            tool_type="function",
        )
    
    # 同步 agent as tools
    for tool_id, metadata in self._agent_as_tools.items():
        save_tool(
            tool_id=tool_id,
            name=metadata.name,
            description=metadata.description,
            task=metadata.task,
            agent_type=",".join(metadata.agent_types),
            input_params=metadata.input_params,
            output_type=metadata.output_type,
            output_description=metadata.output_description,
            tool_type="agent_as_tool",
            agent_class_name=metadata.agent_class_name,
        )
```

### 3.6 工具管理 API

#### 3.6.1 后端 API

```python
# backend/main.py

@app.post("/api/tools/register")
async def register_tool(tool_definition: ToolDefinition):
    """动态注册新工具"""
    registry = get_tool_registry()
    registry.register_from_definition(tool_definition)
    registry.sync_to_database()
    return {"status": "success"}

@app.delete("/api/tools/{tool_id}")
async def delete_tool(tool_id: str):
    """删除工具"""
    registry = get_tool_registry()
    registry.unregister_tool(tool_id)
    # 从数据库删除
    from backend.database.tools_db import delete_tool
    delete_tool(tool_id)
    return {"status": "success"}

@app.post("/api/agents/{agent_id}/tools/{tool_id}")
async def add_tool_to_agent(agent_id: str, tool_id: str):
    """给 agent 添加工具"""
    agent = load_agent(agent_id)
    agent.add_tool(tool_id)
    return {"status": "success"}

@app.delete("/api/agents/{agent_id}/tools/{tool_id}")
async def remove_tool_from_agent(agent_id: str, tool_id: str):
    """从 agent 移除工具"""
    agent = load_agent(agent_id)
    agent.remove_tool(tool_id)
    return {"status": "success"}
```

## 4. 实施计划

### 4.1 阶段一：核心基础设施（Week 1）

1. **创建工具注册表**
   - 实现 `ToolRegistry` 类
   - 实现工具元数据结构
   - 实现基本的注册和查找功能

2. **实现装饰器**
   - `@register_function_tool` 装饰器
   - `@register_agent_as_tool` 装饰器
   - 自动注册机制

3. **工具发现机制**
   - 实现自动扫描和注册
   - 启动时初始化

### 4.2 阶段二：工具加载重构（Week 2）

1. **重构工具加载**
   - 修改 `BaseAgent._recreate_tools`
   - 实现统一的工具创建接口
   - 支持 agent_as_tool 加载

2. **数据库同步**
   - 实现元数据同步
   - 迁移现有工具到新系统

3. **向后兼容**
   - 保持旧 API 可用
   - 渐进式迁移现有工具

### 4.3 阶段三：动态管理（Week 3）

1. **动态工具管理**
   - Agent 添加/删除工具方法
   - API 端点实现
   - 前端 UI 支持

2. **工具版本管理**
   - 工具版本追踪
   - 工具更新机制

3. **测试和文档**
   - 单元测试
   - 集成测试
   - 使用文档

## 5. 使用示例

### 5.1 注册 Function Tool

```python
# backend/tools/my_tools.py

from backend.tools.tool_registry import register_function_tool
from agents import function_tool

@register_function_tool(
    tool_id="my_custom_tool",
    name="my_custom_tool",
    description="我的自定义工具",
    agent_types=["BaseAgent", "MasterAgent"],
    input_params={
        "param1": {"type": "str", "description": "参数1", "required": True}
    },
    output_type="str",
)
def create_my_custom_tool(agent: 'BaseAgent'):
    @function_tool
    def my_custom_tool(param1: str) -> str:
        """执行自定义操作"""
        return f"处理了: {param1}"
    return my_custom_tool
```

### 5.2 注册 Agent as Tool

```python
# backend/agent/specialized/MyAgent.py

from backend.tools.tool_registry import register_agent_as_tool
from agents import Agent

@register_agent_as_tool(
    tool_id="my_agent_as_tool",
    name="my_agent_as_tool",
    description="我的 Agent as Tool",
    agent_class_name="MyAgent",
    agent_types=["MasterAgent"],
    input_params={
        "input": {"type": "str", "description": "输入", "required": True}
    },
    output_type="str",
)
class MyAgent(Agent):
    def __init__(self, input: str):
        super().__init__(
            name="MyAgent",
            instructions="处理输入的 Agent"
        )
        self.input = input
```

### 5.3 Agent 使用工具

```python
# 自动加载（从数据库）
agent = load_agent(agent_id)
# agent.tools 已自动加载

# 动态添加
agent.add_tool("my_custom_tool")

# 动态删除
agent.remove_tool("send_message")
```

## 6. 优势总结

1. **易于扩展**：使用装饰器，添加新工具只需几行代码
2. **自动管理**：工具自动发现和注册，无需手动配置
3. **动态灵活**：支持运行时添加/删除工具
4. **数据库驱动**：工具元数据集中管理
5. **向后兼容**：现有代码无需修改即可工作
6. **类型安全**：通过元数据定义，提供类型检查支持

## 7. 注意事项

1. **循环导入**：注意工具注册时的导入顺序
2. **性能考虑**：工具发现和注册在启动时执行
3. **错误处理**：工具创建失败时的降级策略
4. **版本兼容**：工具版本变更时的兼容性处理
